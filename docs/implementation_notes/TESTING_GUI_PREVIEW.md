# GUIプレビュー機能とプロセス分離のテストガイド

## 概要

タスク14で実装したプレビュー表示とプロセス分離機能のテストガイドです。

## 実装された機能

### 1. 制御パネルの改修
- ウィンドウ選択ボタンと開始/停止ボタンを分離
- ステータス表示を更新（プレビュー中/処理中/停止中/一時停止中）
- ウィンドウ選択後、即座にプレビュー表示を開始

### 2. プレビューループの分離
- プレビュー専用スレッド（キャプチャのみ実行）
- ウィンドウ選択後、自動的にプレビューループを開始
- プレビュー状態フラグの管理（preview_active）

### 3. 処理ループの分離
- 物体検知とOCR処理専用スレッド
- 開始ボタン押下時のみ処理ループを開始
- 停止ボタン押下時、処理ループを停止（プレビューは継続）
- 処理状態フラグの管理（processing_active）

### 4. スレッド間の状態管理
- プレビューモード、アクティブモード、一時停止モードの状態遷移
- 各モードでの動作を明確に分離
- スレッドセーフな状態管理（threading.Lock使用）

## 状態遷移図

```
停止中 (stopped)
    ↓ [ウィンドウを選択してプレビュー]
プレビュー中 (preview) ← キャプチャのみ実行
    ↓ [開始]
処理中 (processing) ← キャプチャ + 物体検知 + OCR
    ↓ [一時停止]
一時停止中 (paused) ← プレビューは継続、処理は停止
    ↓ [再開]
処理中 (processing)
    ↓ [停止]
プレビュー中 (preview)
    ↓ [プレビューを停止]
停止中 (stopped)
```

## テスト手順

### 前提条件
1. 仮想環境がアクティブ化されている
2. 必要な依存関係がインストールされている
3. YOLOv8モデルファイル（models/best.pt）が存在する
4. macOSの画面収録権限が付与されている

### テストケース1: ウィンドウ選択とプレビュー表示

```bash
# GUIアプリケーションを起動
./venv/bin/python src/gui_app.py
```

**手順:**
1. アプリケーションが起動し、ステータスが「停止中」（黒色）であることを確認
2. ウィンドウタイトルのドロップダウンから対象ウィンドウを選択（例: "iPhone"）
3. 「ウィンドウを選択してプレビュー」ボタンをクリック
4. ステータスが「プレビュー中」（青色）に変わることを確認
5. プレビューウィンドウにキャプチャされた画面が表示されることを確認
6. 「開始」ボタンが有効になることを確認

**期待される結果:**
- プレビューがリアルタイムで更新される
- 物体検知の矩形は表示されない（プレビューのみ）
- ログには何も表示されない

### テストケース2: 処理の開始と停止

**手順:**
1. プレビュー中の状態から「開始」ボタンをクリック
2. ステータスが「処理中」（緑色）に変わることを確認
3. プレビューウィンドウに緑色の矩形（検出結果）が表示されることを確認
4. ログパネルに抽出されたテキストが表示されることを確認
5. 統計情報が更新されることを確認
6. 「停止」ボタンをクリック
7. ステータスが「プレビュー中」（青色）に戻ることを確認
8. プレビューは継続されるが、矩形は表示されなくなることを確認

**期待される結果:**
- 処理中は物体検知とOCRが実行される
- 停止後もプレビューは継続される
- ログへの追加が停止される

### テストケース3: 一時停止と再開

**手順:**
1. 処理中の状態から「一時停止」ボタンをクリック
2. ステータスが「一時停止中」（オレンジ色）に変わることを確認
3. プレビューは継続されるが、ログへの追加が停止することを確認
4. 「再開」ボタンをクリック
5. ステータスが「処理中」（緑色）に戻ることを確認
6. ログへの追加が再開されることを確認

**期待される結果:**
- 一時停止中もプレビューは継続される
- 処理（物体検知・OCR）のみが停止される
- 再開後、処理が正常に再開される

### テストケース4: プレビューの停止

**手順:**
1. 処理中の状態から「プレビューを停止」ボタンをクリック
2. 処理とプレビューの両方が停止することを確認
3. ステータスが「停止中」（黒色）に変わることを確認
4. プレビューウィンドウが黒くなることを確認
5. 「開始」ボタンが無効になることを確認

**期待される結果:**
- すべてのスレッドが安全に停止される
- UIが初期状態に戻る

### テストケース5: エラーハンドリング

**手順:**
1. 存在しないウィンドウタイトルを入力
2. 「ウィンドウを選択してプレビュー」ボタンをクリック
3. エラーダイアログが表示されることを確認
4. ステータスが「停止中」のままであることを確認

**期待される結果:**
- 適切なエラーメッセージが表示される
- アプリケーションがクラッシュしない

## 確認項目

### 機能面
- [ ] ウィンドウ選択後、即座にプレビューが開始される
- [ ] プレビュー中は物体検知・OCRが実行されない
- [ ] 開始ボタン押下後、物体検知・OCRが実行される
- [ ] 停止ボタン押下後、プレビューは継続される
- [ ] 一時停止中もプレビューは継続される
- [ ] プレビュー停止ボタンで全てが停止される

### UI面
- [ ] ステータス表示が正しく更新される
- [ ] ステータスの色が状態に応じて変わる（黒/青/緑/オレンジ）
- [ ] ボタンの有効/無効が適切に切り替わる
- [ ] ボタンのラベルが状態に応じて変わる

### パフォーマンス面
- [ ] プレビューがスムーズに表示される（~30 FPS）
- [ ] 処理中もフレームレートが維持される
- [ ] メモリリークが発生しない
- [ ] スレッドが適切に終了する

### エラーハンドリング
- [ ] 存在しないウィンドウの選択時にエラーが表示される
- [ ] モデルファイルが存在しない場合にエラーが表示される
- [ ] 処理中のエラーでアプリケーションがクラッシュしない

## トラブルシューティング

### プレビューが表示されない
- macOSの画面収録権限を確認
- ウィンドウタイトルが正しいか確認
- ターミナルでエラーメッセージを確認

### 処理が開始されない
- モデルファイル（models/best.pt）が存在するか確認
- Tesseract OCRがインストールされているか確認
- ログパネルでエラーメッセージを確認

### フレームレートが低い
- Apple Silicon環境でMPSが有効か確認
- 他のアプリケーションを閉じてリソースを確保
- 信頼度しきい値を上げて検出数を減らす

## 実装の詳細

### スレッド構成
1. **メインスレッド**: GUI更新とイベント処理
2. **プレビュースレッド**: ウィンドウキャプチャのみ
3. **処理スレッド**: 物体検知 + OCR処理

### 状態管理
- `preview_active`: プレビュースレッドが実行中
- `processing_active`: 処理スレッドが実行中
- `is_paused`: 処理が一時停止中
- `state_lock`: スレッドセーフな状態管理用のロック

### イベント
- `preview_stop_event`: プレビュースレッドの停止シグナル
- `processing_stop_event`: 処理スレッドの停止シグナル

## 次のステップ

このテストが完了したら、以下の追加機能を検討できます：

1. プレビューのフレームレート調整機能
2. 処理中のリアルタイム統計表示（FPS、処理時間など）
3. 検出結果のオーバーレイ表示の改善
4. 複数ウィンドウの同時プレビュー
5. プレビューのスナップショット保存機能

## 参考

- Requirements: 3.1, 3.2, 3.3, 3.7, 3.8, 8.4
- Design: プレビューモード、アクティブモード、一時停止モードの状態遷移
